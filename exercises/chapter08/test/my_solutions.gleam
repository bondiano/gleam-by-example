//// Здесь вы можете писать свои решения упражнений.
//// Тема: Erlang FFI и системное программирование

import gleam/erlang/atom
import gleam/erlang/process

// ============================================================
// Упражнение 1: system_time_seconds — FFI к erlang:system_time
// ============================================================

/// Возвращает текущее время в секундах через FFI к Erlang.
///
/// Подсказка: используйте @external(erlang, "erlang", "system_time")
/// с атомом "second". Создайте атом через:
/// @external(erlang, "erlang", "binary_to_atom")
/// fn binary_to_atom(s: String) -> atom.Atom
pub fn system_time_seconds() -> Int {
  todo as "Упражнение 1: реализуйте system_time_seconds"
}

// ============================================================
// Упражнение 2: get_api_base_url — переменные окружения
// ============================================================

/// Получает POKEAPI_BASE_URL из окружения или возвращает
/// "https://pokeapi.co" по умолчанию.
///
/// Подсказка: создайте chapter08_ffi.erl с функцией get_env/1
/// (как в примере из текста главы), затем используйте
/// @external(erlang, "chapter08_ffi", "get_env")
pub fn get_api_base_url() -> String {
  todo as "Упражнение 2: реализуйте get_api_base_url"
}

// ============================================================
// Упражнение 3: file_exists — проверка существования файла
// ============================================================

/// Проверяет, существует ли файл по указанному пути.
///
/// Подсказка: используйте @external(erlang, "filelib", "is_file")
/// Не забудьте преобразовать String в Charlist через
/// charlist.from_string()
pub fn file_exists(path: String) -> Bool {
  todo as "Упражнение 3: реализуйте file_exists"
}

// ============================================================
// Упражнение 4: read_lines — чтение файла построчно
// ============================================================

/// Читает файл и разбивает его на строки.
///
/// Подсказка:
/// 1. Используйте FFI к file:read_file/1
/// 2. Преобразуйте BitArray в String через bit_array.to_string
/// 3. Разбейте на строки через string.split(..., "\n")
pub fn read_lines(path: String) -> Result(List(String), String) {
  todo as "Упражнение 4: реализуйте read_lines"
}

// ============================================================
// Упражнение 5: LogLevel — безопасная работа с атомами
// ============================================================

/// Уровни логирования.
pub type LogLevel {
  Debug
  Info
  Warning
  LogError
}

/// Преобразует LogLevel в атом.
///
/// Подсказка: используйте atom.create для каждого варианта
pub fn log_level_to_atom(level: LogLevel) -> atom.Atom {
  todo as "Упражнение 5: реализуйте log_level_to_atom"
}

/// Преобразует атом в LogLevel.
///
/// Подсказка: используйте atom.to_string и pattern matching
pub fn log_level_from_atom(a: atom.Atom) -> Result(LogLevel, Nil) {
  todo as "Упражнение 5: реализуйте log_level_from_atom"
}

// ============================================================
// Упражнение 6: pid_to_string — работа с процессами
// ============================================================

/// Преобразует Pid (идентификатор процесса BEAM) в строку.
///
/// Подсказка: используйте @external(erlang, "erlang", "pid_to_list"),
/// который возвращает Charlist, затем преобразуйте в String
pub fn pid_to_string(pid: process.Pid) -> String {
  todo as "Упражнение 6: реализуйте pid_to_string"
}

// ============================================================
// Упражнение 7: measure_time — измерение времени выполнения
// ============================================================

/// Измеряет время выполнения переданной функции.
/// Возвращает кортеж #(результат, время_в_микросекундах).
///
/// Подсказка:
/// 1. Получите время до вызова через erlang:monotonic_time(microsecond)
/// 2. Вызовите f()
/// 3. Получите время после
/// 4. Вычтите и верните разницу
pub fn measure_time(f: fn() -> a) -> #(a, Int) {
  todo as "Упражнение 7: реализуйте measure_time"
}

// ============================================================
// Упражнение 8: ensure_dir — создание директории
// ============================================================

/// Создаёт директорию (включая родительские).
///
/// Подсказка: используйте @external(erlang, "filelib", "ensure_dir")
/// Эта функция требует путь к файлу (не директории!),
/// поэтому добавьте "/" в конец пути перед вызовом
pub fn ensure_dir(path: String) -> Result(Nil, String) {
  todo as "Упражнение 8: реализуйте ensure_dir"
}

// ============================================================
// Упражнение 9: simple_ets_cache — работа с ETS
// ============================================================

/// Непрозрачный тип для ETS-кэша.
pub type Cache

/// Создаёт новый ETS-кэш с именем.
///
/// Подсказка: создайте ets_ffi.erl с функцией new_table/1,
/// использующей ets:new(binary_to_atom(Name), [set, public, named_table])
pub fn new_cache(name: String) -> Cache {
  todo as "Упражнение 9: реализуйте new_cache"
}

/// Добавляет пару ключ-значение в кэш.
///
/// Подсказка: используйте ets:insert(Table, {Key, Value})
pub fn cache_put(cache: Cache, key: String, value: String) -> Nil {
  todo as "Упражнение 9: реализуйте cache_put"
}

/// Получает значение из кэша по ключу.
///
/// Подсказка: ets:lookup(Table, Key) возвращает [{Key, Value}] или []
pub fn cache_get(cache: Cache, key: String) -> Result(String, Nil) {
  todo as "Упражнение 9: реализуйте cache_get"
}

/// Удаляет кэш.
///
/// Подсказка: используйте ets:delete(Table)
pub fn cache_delete(cache: Cache) -> Nil {
  todo as "Упражнение 9: реализуйте cache_delete"
}

// ============================================================
// Упражнение 10: spawn_and_receive — процессы и сообщения
// ============================================================

/// Создаёт процесс, который отправляет сообщение "echo" родителю,
/// получает это сообщение и возвращает его.
///
/// Подсказка:
/// 1. Используйте process.self() для получения родительского PID
/// 2. Используйте process.start(fn() { ... }, True) для создания процесса
/// 3. В процессе-потомке отправьте сообщение через process.send(parent_pid, "echo")
/// 4. В родителе получите сообщение через process.receive(selector, timeout)
pub fn spawn_echo() -> String {
  todo as "Упражнение 10: реализуйте spawn_echo"
}
