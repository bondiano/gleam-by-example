# Введение

> Эта глава знакомит с языком Gleam и его местом в мире функционального программирования.

## Цели главы

В этой главе мы:

- Поймём, зачем нужен ещё один функциональный язык
- Познакомимся с BEAM — виртуальной машиной Erlang
- Увидим, чем Gleam отличается от других ФП-языков
- Узнаем, как устроена эта книга

## Зачем ещё один ФП-язык?

Функциональное программирование давно вышло за пределы академии. `map`, `filter` и `reduce` стали привычными в JavaScript, Python и даже Java. Но между «использовать пару приёмов из ФП» и «писать на функциональном языке» — пропасть.

Haskell и OCaml дают мощные системы типов, но у них своя рантайм-среда без встроенной конкурентности промышленного уровня. Elixir и Erlang работают на легендарной BEAM-машине с отказоустойчивостью и конкурентностью из коробки, но лишены статической типизации — ошибки типов обнаруживаются только в рантайме.

Gleam занимает уникальную нишу: это **строго типизированный язык на BEAM**. Он сочетает:

- **Безопасность типов** — ошибки ловятся компилятором, а не пользователем в продакшене
- **Отказоустойчивость BEAM** — процессы, супервизоры, горячая перезагрузка
- **Намеренную простоту** — нет классов типов, нет макросов, нет GADTs

## BEAM: виртуальная машина, проверенная временем

BEAM (Bogdan/Björn's Erlang Abstract Machine) — виртуальная машина, созданная в Ericsson для телекоммуникаций. Её ключевые свойства:

- **Лёгкие процессы** — миллионы конкурентных процессов в одной VM, каждый с собственной кучей
- **Изоляция сбоев** — падение одного процесса не затрагивает другие
- **Горячая перезагрузка** — обновление кода без остановки системы
- **Распределённость** — процессы общаются по сети прозрачно

На BEAM работают системы, обслуживающие сотни миллионов пользователей:

| Система | Масштаб |
|---------|---------|
| WhatsApp | 2 млрд пользователей, ~50 инженеров |
| Discord | Миллионы конкурентных подключений |
| RabbitMQ | Один из самых популярных брокеров сообщений |
| Ericsson | Телекоммуникации с 99.9999999% uptime |

Gleam компилируется в Erlang-байткод и получает все эти свойства бесплатно. Код на Gleam вызывает Erlang- и Elixir-библиотеки напрямую, без обёрток и накладных расходов.

## Двойной таргет

У Gleam есть уникальная особенность: один и тот же код компилируется в **Erlang** (для сервера) и в **JavaScript** (для браузера и Node.js).

```
              ┌─── Erlang (BEAM) ───► сервер, CLI, IoT
gleam build ──┤
              └─── JavaScript ──────► браузер, Node.js
```

Переключение между таргетами — одна строка в `gleam.toml`:

```toml
target = "erlang"   # или "javascript"
```

Стандартная библиотека Gleam работает на обоих таргетах. Для платформо-специфичного кода используется FFI — вызов Erlang- или JavaScript-функций из Gleam-кода.

## Философия Gleam

Gleam — **намеренно минималистичный** язык. Его создатель Louis Pilfold следует принципу: если фичу можно не добавлять — её не добавляют.

В Gleam **нет**:

- Классов типов (type classes)
- Макросов
- GADTs и зависимых типов
- Исключений (в привычном смысле)
- REPL
- Перегрузки операторов
- Неявных приведений типов

Это не ограничение, а осознанный выбор. Каждая строка кода на Gleam читается однозначно: нет скрытой диспетчеризации, нет магии макросов, нет неявных преобразований. Код делает ровно то, что написано.

### Дружелюбные ошибки

Gleam известен исключительно понятными сообщениями об ошибках. Компилятор не просто говорит «type mismatch» — он объясняет, что пошло не так, и часто предлагает исправление:

```
error: Type mismatch
  ┌─ src/main.gleam:4:17
  │
4 │   string.length(42)
  │                 ^^

Expected type:
    String

Found type:
    Int

Hint: try using `int.to_string` to convert the value.
```

### Hex — единая экосистема

Gleam использует **Hex** — менеджер пакетов, общий с Erlang и Elixir. Это означает доступ к тысячам зрелых библиотек:

- Веб-серверы (Cowboy, Plug)
- Базы данных (Ecto, Postgrex)
- Очереди сообщений (Broadway)
- И вся остальная BEAM-экосистема

При этом Gleam-пакеты написаны с полной типобезопасностью и вызываются из Gleam без потери типов.

## Сравнение с другими языками

| | Gleam | Elm | Rust | Elixir | Haskell | OCaml |
|---|---|---|---|---|---|---|
| Статическая типизация | ✓ | ✓ | ✓ | ✗ | ✓ | ✓ |
| BEAM | ✓ | ✗ | ✗ | ✓ | ✗ | ✗ |
| Простота | ✓✓ | ✓ | ✗ | ✓ | ✗ | ✗ |
| Конкурентность (акторы) | ✓ | ✗ | ✗ | ✓ | ✗ | ✗ |
| JS-таргет | ✓ | ✓ | ✗ | ✗ | ✓* | ✓* |
| Зрелая экосистема | Растёт | Средняя | ✓✓ | ✓ | ✓ | ✓ |

\* Haskell компилируется в JS через GHCJS/Asterius, OCaml — через js_of_ocaml/Melange. Однако в обоих случаях это отдельные инструменты, а не встроенная возможность компилятора. В Gleam и Elm JS-таргет — штатный режим работы.

- **Elm** — ближайший родственник по философии (типы + простота), но работает только в браузере
- **Rust** — похожий подход к безопасности, но другой уровень сложности и нет BEAM
- **Elixir** — тот же BEAM, но без статических типов
- **Haskell/OCaml** — мощные системы типов, есть JS-таргеты через сторонние инструменты, но нет BEAM-конкурентности

## Структура книги

Книга состоит из 12 глав, каждая из которых — самостоятельный проект:

| Глава | Тема | Проект |
|-------|------|--------|
| 1 | Введение | — |
| 2 | Начало работы | Задача Эйлера |
| 3 | Функции и пайплайны | Адресная книга |
| 4 | Типы данных и коллекции | Файловая система |
| 5 | Рекурсия и ошибки | Валидация формы |
| 6 | Строки и stdlib | Обработка текста |
| 7 | FFI и интероп | Обёртка над Erlang |
| 8 | Процессы и OTP | Акторы и супервизоры |
| 9 | Тестирование | PBT и снапшоты |
| 10 | Веб с Wisp | REST API |
| 11 | Фронтенд с Lustre | SPA |
| 12 | Telegram-бот | Telega |

Каждая глава содержит:
- Объяснение концепций с примерами кода
- Сквозной проект, демонстрирующий концепции на практике
- Упражнения с подсказками (кроме этой вводной главы)

### Как читать эту книгу

Главы 1–6 лучше читать последовательно — каждая следующая опирается на предыдущую. Главы 7–12 более независимы: можно начать с той темы, которая интереснее.

Упражнения — важная часть обучения. Решения находятся в директории `no-peeking/`, но попробуйте решить задачу самостоятельно, прежде чем подсматривать.

### О читателе

Книга предполагает:

- Опыт программирования на любом языке (Python, JavaScript, Go, Java — неважно)
- Базовое понимание командной строки (терминал, `cd`, запуск команд)
- Знакомство с Git (на уровне `clone`, `commit`, `push`)

Опыт функционального программирования **не требуется** — мы объясняем все концепции с нуля.

### Ресурсы

- [Gleam — официальный сайт](https://gleam.run/)
- [Gleam Language Tour](https://tour.gleam.run/) — интерактивный тур по языку
- [Exercism — Gleam Track](https://exercism.org/tracks/gleam) — упражнения с менторингом
- [Awesome Gleam](https://github.com/gleam-community/awesome-gleam) — каталог библиотек
- [Gleam Discord](https://discord.gg/Fm8Pwmy) — сообщество

## Заключение

Gleam — молодой, но быстро растущий язык. Он берёт лучшее из двух миров: надёжность статической типизации и промышленную конкурентность BEAM. При этом он остаётся простым — выучить весь язык можно за выходные.

В следующей главе мы установим Gleam, создадим первый проект и напишем первую программу.
