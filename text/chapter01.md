# Введение

> Эта глава знакомит с языком Gleam и его местом в мире функционального программирования.

<!-- toc -->

## Цели главы

В этой главе мы:

- Поймём, зачем нужен ещё один функциональный язык
- Познакомимся с BEAM — виртуальной машиной Erlang
- Увидим, чем Gleam отличается от других ФП-языков
- Узнаем, как устроена эта книга

## Зачем ещё один ФП-язык?

Функциональное программирование давно вышло за пределы академии. `map`, `filter` и `reduce` стали привычными в JavaScript, Python и даже Java. Но между «использовать пару приёмов из ФП» и «писать на функциональном языке» — пропасть.

Haskell и OCaml дают мощные системы типов, но у них своя рантайм-среда без встроенной конкурентности промышленного уровня. Elixir и Erlang работают на легендарной BEAM-машине с отказоустойчивостью и конкурентностью из коробки, но лишены статической типизации — ошибки типов обнаруживаются только в рантайме.

Gleam занимает уникальную нишу: это **строго типизированный язык на BEAM**. Он сочетает:

- **Безопасность типов** — ошибки ловятся компилятором, а не пользователем в продакшене
- **Отказоустойчивость BEAM** — процессы, супервизоры, горячая перезагрузка
- **Намеренную простоту** — нет классов типов, нет макросов, нет GADTs

## BEAM: виртуальная машина, проверенная временем

BEAM (Bogdan/Björn's Erlang Abstract Machine) — виртуальная машина, созданная в Ericsson для телекоммуникаций. Её ключевые свойства:

- **Лёгкие процессы** — миллионы конкурентных процессов в одной VM, каждый с собственной кучей
- **Изоляция сбоев** — падение одного процесса не затрагивает другие
- **Горячая перезагрузка** — обновление кода без остановки системы
- **Распределённость** — процессы общаются по сети прозрачно

На BEAM работают системы, обслуживающие сотни миллионов пользователей:

| Система | Масштаб |
| --------- | --------- |
| WhatsApp | 2 млрд пользователей, ~50 инженеров |
| Discord | Миллионы конкурентных подключений |
| RabbitMQ | Один из самых популярных брокеров сообщений |
| Ericsson | Телекоммуникации с 99.9999999% uptime |

Gleam компилируется в Erlang-байткод и получает все эти свойства бесплатно. Код на Gleam вызывает Erlang- и Elixir-библиотеки напрямую, без обёрток и накладных расходов.

## Двойной таргет

У Gleam есть уникальная особенность: один и тот же код компилируется в **Erlang** (для сервера) и в **JavaScript** (для браузера и Node.js).

```text
              ┌─── Erlang (BEAM) ───► сервер, CLI, IoT
gleam build ──┤
              └─── JavaScript ──────► браузер, Node.js
```

Переключение между таргетами — одна строка в `gleam.toml`:

```toml
target = "erlang"   # или "javascript"
```

Стандартная библиотека Gleam работает на обоих таргетах. Для платформо-специфичного кода используется FFI — вызов Erlang- или JavaScript-функций из Gleam-кода.

## Философия Gleam

Gleam — **намеренно минималистичный** язык. Его создатель Louis Pilfold следует принципу: если фичу можно не добавлять — её не добавляют.

В Gleam **нет**:

- Классов типов (type classes)
- Макросов
- GADTs и зависимых типов
- Исключений (в привычном смысле)
- REPL
- Перегрузки операторов
- Неявных приведений типов

Это не ограничение, а осознанный выбор. Каждая строка кода на Gleam читается однозначно: нет скрытой диспетчеризации, нет магии макросов, нет неявных преобразований. Код делает ровно то, что написано.

### Дружелюбные ошибки

Gleam известен исключительно понятными сообщениями об ошибках. Компилятор не просто говорит «type mismatch» — он объясняет, что пошло не так, и часто предлагает исправление:

```text
error: Type mismatch
  ┌─ src/main.gleam:4:17
  │
4 │   string.length(42)
  │                 ^^

Expected type:
    String

Found type:
    Int

Hint: try using `int.to_string` to convert the value.
```

Компилятор указывает точную строку и столбец ошибки, показывает ожидаемый и найденный тип, и сразу предлагает исправление. Это делает работу с Gleam особенно приятной для новичков.

### Hex — единая экосистема

Gleam использует **Hex** — менеджер пакетов, общий с Erlang и Elixir. Это означает доступ к тысячам зрелых библиотек:

- Веб-серверы (Cowboy, Plug)
- Базы данных (Ecto, Postgrex)
- Очереди сообщений (Broadway)
- И вся остальная BEAM-экосистема

При этом Gleam-пакеты написаны с полной типобезопасностью и вызываются из Gleam без потери типов.

## Сравнение с другими языками

| | Gleam | Elm | Rust | Elixir | Haskell | OCaml |
| --- | --- | --- | --- | --- | --- | --- |
| Статическая типизация | ✓ | ✓ | ✓ | ✗ | ✓ | ✓ |
| BEAM | ✓ | ✗ | ✗ | ✓ | ✗ | ✗ |
| Простота | ✓✓ | ✓ | ✗ | ✓ | ✗ | ✗ |
| Конкурентность (акторы) | ✓ | ✗ | ✗ | ✓ | ✗ | ✗ |
| JS-таргет | ✓ | ✓ | ✗ | ✗ | ✓* | ✓* |
| Зрелая экосистема | Растёт | Средняя | ✓✓ | ✓ | ✓ | ✓ |

\* Haskell компилируется в JS через GHCJS/Asterius, OCaml — через js_of_ocaml/Melange. Однако в обоих случаях это отдельные инструменты, а не встроенная возможность компилятора. В Gleam и Elm JS-таргет — штатный режим работы.

- **Elm** — ближайший родственник по философии (типы + простота), но работает только в браузере
- **Rust** — похожий подход к безопасности, но другой уровень сложности и нет BEAM
- **Elixir** — тот же BEAM, но без статических типов
- **Haskell/OCaml** — мощные системы типов, есть JS-таргеты через сторонние инструменты, но нет BEAM-конкурентности

## Структура книги

Книга состоит из 14 глав и приложений:

| Глава | Тема |
| ------- | ------ |
| 1 | Введение |
| 2 | Начало работы |
| 3 | Функции и пайплайны |
| 4 | Типы данных и коллекции |
| 5 | Рекурсия, свёртки и обработка ошибок |
| 6 | Строки, битовые массивы и стандартная библиотека |
| 7 | Type Safety и Parse Don't Validate |
| 8 | Erlang FFI и системное программирование |
| 9 | JavaScript FFI и фронтенд интеграция |
| 10 | Процессы и OTP |
| 11 | Тестирование |
| 12 | Веб-разработка с Wisp |
| 13 | Фронтенд с Lustre |
| 14 | Заключение и следующие шаги |

**Приложения:**

- Приложение A: Telegram-бот с Telega

Каждая глава содержит:

- Объяснение концепций с примерами кода
- Сквозной проект, демонстрирующий концепции на практике
- Упражнения с подсказками (кроме этой вводной главы)

### Как читать эту книгу

Начинающим рекомендуется читать главы последовательно, так как ранний материал закладывает фундаментальные концепции. Однако тем, кто уже знаком с функциональным программированием — особенно в строго типизированных языках — можно пропускать известные темы.

Каждая глава (со 2-й по 13-ю) построена вокруг **практического примера**, который служит мотивацией для новых идей. Главы 2–7 образуют базовый курс и лучше изучать последовательно. Главы 8–13 более независимы и покрывают специализированные темы: FFI, OTP, тестирование, веб-разработку.

Код из репозитория следует изучать **вместе с текстом** для полного понимания:

```bash
exercises/
├── chapter02/      # Начало работы
├── chapter03/      # Функции и пайплайны
├── ...
├── chapter13/      # Фронтенд с Lustre
└── appendix_a/     # Telegram-бот
```

Каждая директория содержит:

- `src/chapterXX.gleam` — примеры кода из текста главы
- `test/my_solutions.gleam` — шаблоны для ваших решений
- `no-peeking/solutions.gleam` — референсные решения

**Это не справочник с готовыми шаблонами.** Для максимального эффекта от обучения настоятельно рекомендуется:

1. Читать главу и изучать примеры кода
2. **Решать упражнения самостоятельно** — каждое упражнение снабжено подсказками
3. Запускать тесты: `cd exercises/chapterXX && gleam test`
4. Только после попыток решения смотреть в `no-peeking/solutions.gleam`

Упражнения — неотъемлемая часть понимания материала. Проработка их критически важна для усвоения концепций.

### О читателе

Книга предполагает:

- Опыт программирования на любом языке (Python, JavaScript, Go, Java — неважно)
- Базовое понимание командной строки (терминал, `cd`, запуск команд)
- Знакомство с Git (на уровне `clone`, `commit`, `push`)

Опыт функционального программирования **не требуется** — мы объясняем все концепции с нуля.

### Ресурсы

- [Gleam — официальный сайт](https://gleam.run/)
- [Gleam Language Tour](https://tour.gleam.run/) — интерактивный тур по языку
- [Exercism — Gleam Track](https://exercism.org/tracks/gleam) — упражнения с менторингом
- [Awesome Gleam](https://github.com/gleam-lang/awesome-gleam) — каталог библиотек
- [Gleam Discord](https://discord.gg/Fm8Pwmy) — сообщество

## Заключение

Gleam — молодой, но быстро растущий язык. Он берёт лучшее из двух миров: надёжность статической типизации и промышленную конкурентность BEAM. При этом он остаётся простым — выучить весь язык можно за выходные.

В следующей главе мы установим Gleam, создадим первый проект и напишем первую программу.
